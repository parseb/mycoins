// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/ERC20GM.sol";

//// @note this tests were generated by chatgpt... mostly.
contract ERC20GMTest is Test {
    ERC20GM erc20gm;
    address owner;
    address alice;
    address bob;
    address charlie;

    function setUp() public {
        erc20gm = new ERC20GM("MyToken", "MTK", 100, new address[](0), new uint256[](0));
        owner = address(this);
        alice = address(0x01);
        bob = address(0x02);
        charlie = address(0x03);
        // erc20gm.transferOwnership(owner); lol
    }

    function test_mint() public payable {
        uint256 amount = 10;
        uint256 expectedValue = amount * erc20gm.price();

        erc20gm.mint{value: expectedValue}(amount);

        assertEq(expectedValue, address(erc20gm).balance);
        assertEq(amount, erc20gm.balanceOf(address(this)));
    }

    function test_mint_with_incorrect_value() public payable {
        uint256 amount = 10;

        vm.expectRevert();
        erc20gm.mint{value: 1}(amount);

        assertEq(0, erc20gm.balanceOf(address(this)));
    }

    function test_burn() public payable {
        address A = address(5345);
        deal(A, 100000 ether);
        uint256 amount = 1 ether;
        uint256 expectedValue = amount * erc20gm.price();

        vm.prank(A);
        erc20gm.mint{value: expectedValue}(amount);
        uint256 refund = erc20gm.refundQtFor(amount);

        uint256 initialBalance = A.balance;

        console.log(amount, " -a-exV ", expectedValue);
        vm.prank(A);
        erc20gm.burn(amount);
        uint256 finalBalance = A.balance;

        assertEq(refund, finalBalance - initialBalance);
        assertEq(0, erc20gm.balanceOf(A));
    }

    function test_signal() public {
        uint256 price = 101;
        uint256 balance = erc20gm.balanceOf(owner);

        erc20gm.signal(price);

        assertEq(balance, erc20gm.signalStrength(price));
        assertEq(balance, erc20gm.signalOf(owner)[1]);
    }

    function test_signal_with_invalid_price() public {
        uint256 invalidPrice = erc20gm.price() - 1;
        uint256 balance = erc20gm.balanceOf(owner);

        vm.expectRevert();
        erc20gm.signal(invalidPrice);

        assertEq(0, erc20gm.signalStrength(invalidPrice));
        assertEq(0, erc20gm.signalOf(owner)[0]);
        assertEq(0, erc20gm.signalOf(owner)[1]);
    }

    function test_howMuchFor() public {
        uint256 amount = 10;

        uint256 expectedValue = amount * erc20gm.price();

        assertEq(expectedValue, erc20gm.howMuchFor(amount));
    }
}
